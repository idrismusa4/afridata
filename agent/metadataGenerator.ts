// This file handles AI-based classification and metadata generation (Level 4).

import { GoogleGenAI } from "@google/genai";

// Define the Dataset Metadata Schema based on the PRD.
export interface DatasetMetadata {
  id: string; // This will likely be generated upon storage
  title: string;
  summary: string;
  tags: string[];
  source_url: string; // Original URL from search result
  file_url: string; // URL where the file is stored (after download/processing)
  file_type: "PDF" | "CSV" | "Web" | "ZIP";
  country: string;
  ai_score: number; // Relevance score
  created_at: string; // Timestamp
}

// Initialize Gemini (ensure API key is available as an environment variable)
const genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

export async function generateMetadata(
  content: string, // Content extracted from the source (e.g., text from PDF, sample from CSV, summary from web page)
  fileType: "PDF" | "CSV" | "Web" | "ZIP",
  sourceUrl: string // Original URL needed for metadata
): Promise<DatasetMetadata | null> {
  console.log(`Generating metadata for ${fileType} source from ${sourceUrl} using Gemini API.`);

  // Prompt for Gemini to extract structured metadata
  const prompt = `Analyze the following content from a ${fileType} file found at ${sourceUrl}. Extract the following information and return it as a JSON object:\n\n-   title: A concise title for the dataset.\n-   summary: A brief summary of the dataset content.\n-   tags: An array of relevant keywords or tags.\n-   country: The primary country the dataset relates to (infer from content or URL if possible, return \"Unknown\" if not specific).\n-   ai_score: A relevance score for potential African use cases on a scale of 1 to 5 (1 being least relevant, 5 being most relevant).\n-   file_type: The type of the file (should be ${fileType}).\n- source_url: The original URL of the source.\n\nEnsure the output is a valid JSON object matching the following TypeScript interface structure:\n\ninterface DatasetMetadata {\n  title: string;\n  summary: string;\n  tags: string[];
  country: string;
  ai_score: number;
  file_type: "PDF" | "CSV" | "Web" | "ZIP";
  source_url: string;
}\n\nHere is the content:\n\n${content}`;

  try {
    const result = await genAI.models.generateContent({
      model: "gemini-pro",
      contents: prompt,
    });
    const responseText = result.text;

    if (!responseText) {
      console.error("Gemini API did not return text content.", result);
      return null; // Return null if no text content
    }

    // Attempt to parse the JSON response
    // The API might return markdown like ```json { ... } ```, so we need to handle that.
    const jsonMatch = responseText.match(/```json\\n([\\s\\S]*)\\n```/);
    let metadata: DatasetMetadata;

    if (jsonMatch && jsonMatch[1]) {
      metadata = JSON.parse(jsonMatch[1]);
    } else {
       // If no markdown, try parsing directly (assuming the model might just return the JSON object)
       metadata = JSON.parse(responseText);
    }

    // Validate the parsed metadata against the expected structure (basic validation)
    if (!metadata || typeof metadata.title !== 'string' || typeof metadata.summary !== 'string' || !Array.isArray(metadata.tags) || typeof metadata.country !== 'string' || typeof metadata.ai_score !== 'number') {
        console.error("Gemini API returned invalid metadata structure.", metadata);
        return null; // Return null if the structure is unexpected
    }

    // Add fields not generated by AI (or ensure they are correct)
    // We already know fileType and sourceUrl from the function parameters
    const completeMetadata: DatasetMetadata = {
        ...metadata,
        id: 'temp-id-' + Math.random().toString(36).substring(7), // Temporary ID
        source_url: sourceUrl, // Ensure correct source URL is used
        file_type: fileType, // Ensure correct file type is used
        created_at: new Date().toISOString(),
    };

    console.log("Metadata generated successfully:");
    console.log(completeMetadata);

    return completeMetadata;

  } catch (error: any) {
    console.error(`Error generating metadata for ${sourceUrl}: ${error.message}`);
    return null; // Return null if API call or parsing fails
  }
} 